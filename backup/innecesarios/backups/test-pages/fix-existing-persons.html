<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß Fix Existing Persons - FC24</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
        }
        .log {
            background: #111;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        button {
            background: #00ff9d;
            color: black;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-weight: bold;
        }
        button:hover {
            background: #00cc7d;
        }
        .danger { background: #ff4444; color: white; }
        .warning { background: #ffaa00; color: black; }
        
        .person-card {
            background: #222;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        
        .person-card.problematic {
            border-color: #ff4444;
            background: #2a1a1a;
        }
        
        .person-card.fixable {
            border-color: #ffaa00;
            background: #2a2a1a;
        }
        
        .id-comparison {
            background: #333;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }
        
        .firebase-id { color: #ff4444; }
        .cache-id { color: #00ff9d; }
        
        h2 { color: #00ff9d; }
        h3 { color: #ffaa00; }
    </style>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
</head>
<body>
    <div class="container">
        <h1>üîß Fix Existing Persons - ID Mismatch Resolver</h1>
        
        <div class="section">
            <h2>üîç ID Mismatch Analysis</h2>
            <p>This tool will identify persons with mismatched IDs between Firebase and cache</p>
            <button onclick="analyzePersonIDs()">üî¨ Analyze Person IDs</button>
            <div id="analysis-results"></div>
        </div>

        <div class="section">
            <h2>üõ†Ô∏è Problem Resolution</h2>
            <div id="fix-options" style="display: none;">
                <p>Choose how to fix the ID mismatches:</p>
                <button onclick="fixByUpdatingCache()" class="warning">üîÑ Fix by Updating Cache IDs</button>
                <button onclick="fixByRecreatingPersons()" class="danger">üîÑ Fix by Recreating Persons</button>
                <button onclick="deleteProblematicPersons()" class="danger">üóëÔ∏è Delete Problematic Persons</button>
            </div>
        </div>

        <div class="section">
            <h2>‚úÖ Verification</h2>
            <button onclick="verifyFixes()">üîç Verify All Persons Can Be Deleted</button>
            <div id="verification-results"></div>
        </div>

        <div class="section">
            <h2>üìù Detailed Logs</h2>
            <button onclick="clearLogs()">üßπ Clear Logs</button>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script src="js/firebase-simple.js"></script>
    
    <script>
        let problematicPersons = [];
        let allFirebasePersons = [];
        let allCachePersons = [];

        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff4444' : type === 'success' ? '#44ff44' : type === 'warning' ? '#ffaa00' : '#ccc';
            logElement.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        function clearLogs() {
            document.getElementById('log').innerHTML = '';
        }

        async function analyzePersonIDs() {
            log('üî¨ Starting ID mismatch analysis...', 'info');
            
            try {
                // Get persons directly from Firebase
                log('üì• Loading persons directly from Firebase...', 'info');
                const firebaseSnapshot = await db.collection('persons').get();
                allFirebasePersons = [];
                
                firebaseSnapshot.forEach(doc => {
                    const data = doc.data();
                    allFirebasePersons.push({
                        firebaseDocumentId: doc.id,  // The real Firebase document ID
                        dataId: data.id,             // The ID stored in the data
                        name: data.name,
                        email: data.email,
                        data: data
                    });
                });
                
                log(`üìä Found ${allFirebasePersons.length} persons in Firebase`, 'info');
                
                // Get persons from cache
                log('üíæ Loading persons from cache...', 'info');
                await Storage.loadPersonsFromFirebase();
                allCachePersons = Storage.getPersons();
                log(`üìä Found ${allCachePersons.length} persons in cache`, 'info');
                
                // Analyze mismatches
                problematicPersons = [];
                let matchingPersons = [];
                
                for (const fbPerson of allFirebasePersons) {
                    const firebaseDocId = fbPerson.firebaseDocumentId;
                    const dataId = fbPerson.dataId;
                    
                    log(`üîç Analyzing person: ${fbPerson.name}`, 'info');
                    log(`  Firebase Doc ID: ${firebaseDocId}`, 'info');
                    log(`  Data ID: ${dataId}`, 'info');
                    
                    // Check if IDs match
                    if (firebaseDocId !== dataId) {
                        log(`‚ùå ID MISMATCH for ${fbPerson.name}: Firebase(${firebaseDocId}) vs Data(${dataId})`, 'error');
                        problematicPersons.push({
                            ...fbPerson,
                            mismatchType: 'id_mismatch',
                            issue: `Firebase document ID (${firebaseDocId}) does not match data ID (${dataId})`
                        });
                    } else {
                        log(`‚úÖ ID MATCH for ${fbPerson.name}`, 'success');
                        matchingPersons.push(fbPerson);
                    }
                }
                
                // Display results
                displayAnalysisResults(problematicPersons, matchingPersons);
                
                if (problematicPersons.length > 0) {
                    document.getElementById('fix-options').style.display = 'block';
                    log(`üö® Found ${problematicPersons.length} persons with ID mismatches`, 'error');
                } else {
                    log('‚úÖ All persons have matching IDs', 'success');
                }
                
            } catch (error) {
                log('‚ùå Error analyzing person IDs: ' + error.message, 'error');
            }
        }

        function displayAnalysisResults(problematic, matching) {
            const resultsDiv = document.getElementById('analysis-results');
            
            let html = `
                <h3>Analysis Results</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h4 style="color: #44ff44;">‚úÖ OK Persons (${matching.length})</h4>
                        ${matching.map(p => `
                            <div class="person-card">
                                <strong>${p.name}</strong><br>
                                <small>ID: ${p.firebaseDocumentId}</small>
                            </div>
                        `).join('') || '<div style="color: #888;">None</div>'}
                    </div>
                    <div>
                        <h4 style="color: #ff4444;">‚ùå Problematic Persons (${problematic.length})</h4>
                        ${problematic.map(p => `
                            <div class="person-card problematic">
                                <strong>${p.name}</strong><br>
                                <div class="id-comparison">
                                    <div class="firebase-id">Firebase ID: ${p.firebaseDocumentId}</div>
                                    <div class="cache-id">Data ID: ${p.dataId}</div>
                                </div>
                                <small>${p.issue}</small>
                            </div>
                        `).join('') || '<div style="color: #888;">None</div>'}
                    </div>
                </div>
            `;
            
            resultsDiv.innerHTML = html;
        }

        async function fixByUpdatingCache() {
            if (problematicPersons.length === 0) {
                alert('No problematic persons to fix');
                return;
            }
            
            if (!confirm(`Fix ${problematicPersons.length} persons by updating their cache IDs to match Firebase?`)) {
                return;
            }
            
            log('üîÑ Fixing persons by updating cache IDs...', 'info');
            
            try {
                let fixed = 0;
                
                for (const person of problematicPersons) {
                    log(`üîÑ Fixing ${person.name}: updating ID from ${person.dataId} to ${person.firebaseDocumentId}`, 'info');
                    
                    // Update the document in Firebase with the correct ID
                    await db.collection('persons').doc(person.firebaseDocumentId).update({
                        id: person.firebaseDocumentId
                    });
                    
                    fixed++;
                    log(`‚úÖ Fixed ${person.name}`, 'success');
                }
                
                log(`‚úÖ Fixed ${fixed}/${problematicPersons.length} persons`, 'success');
                
                // Reload and re-analyze
                await analyzePersonIDs();
                
            } catch (error) {
                log('‚ùå Error fixing persons: ' + error.message, 'error');
            }
        }

        async function fixByRecreatingPersons() {
            if (problematicPersons.length === 0) {
                alert('No problematic persons to fix');
                return;
            }
            
            if (!confirm(`Recreate ${problematicPersons.length} persons with correct IDs? This will delete and recreate them.`)) {
                return;
            }
            
            log('üîÑ Fixing persons by recreating them...', 'warning');
            
            try {
                let recreated = 0;
                
                for (const person of problematicPersons) {
                    log(`üîÑ Recreating ${person.name}...`, 'info');
                    
                    // Delete the old document
                    await db.collection('persons').doc(person.firebaseDocumentId).delete();
                    log(`üóëÔ∏è Deleted old document for ${person.name}`, 'info');
                    
                    // Create new document with correct ID
                    const newPerson = {
                        ...person.data,
                        id: person.firebaseDocumentId
                    };
                    
                    await db.collection('persons').doc(person.firebaseDocumentId).set(newPerson);
                    
                    recreated++;
                    log(`‚úÖ Recreated ${person.name} with correct ID`, 'success');
                }
                
                log(`‚úÖ Recreated ${recreated}/${problematicPersons.length} persons`, 'success');
                
                // Reload and re-analyze
                await analyzePersonIDs();
                
            } catch (error) {
                log('‚ùå Error recreating persons: ' + error.message, 'error');
            }
        }

        async function deleteProblematicPersons() {
            if (problematicPersons.length === 0) {
                alert('No problematic persons to delete');
                return;
            }
            
            if (!confirm(`DELETE ${problematicPersons.length} problematic persons? This cannot be undone!`)) {
                return;
            }
            
            if (!confirm('Are you ABSOLUTELY SURE? This will permanently delete these persons!')) {
                return;
            }
            
            log('üóëÔ∏è Deleting problematic persons...', 'warning');
            
            try {
                let deleted = 0;
                
                for (const person of problematicPersons) {
                    log(`üóëÔ∏è Deleting ${person.name}...`, 'info');
                    
                    // Delete using Firebase document ID
                    await db.collection('persons').doc(person.firebaseDocumentId).delete();
                    
                    deleted++;
                    log(`‚úÖ Deleted ${person.name}`, 'success');
                }
                
                log(`‚úÖ Deleted ${deleted}/${problematicPersons.length} problematic persons`, 'success');
                
                // Reload and re-analyze
                await analyzePersonIDs();
                
            } catch (error) {
                log('‚ùå Error deleting problematic persons: ' + error.message, 'error');
            }
        }

        async function verifyFixes() {
            log('üîç Verifying all persons can be deleted...', 'info');
            
            try {
                // Reload persons
                await Storage.loadPersonsFromFirebase();
                const allPersons = Storage.getPersons();
                
                if (allPersons.length === 0) {
                    log('‚ÑπÔ∏è No persons to verify', 'info');
                    document.getElementById('verification-results').innerHTML = '<div style="color: #888;">No persons to verify</div>';
                    return;
                }
                
                log(`üîç Testing deletion of ${allPersons.length} persons...`, 'info');
                
                let verificationResults = [];
                
                for (const person of allPersons) {
                    log(`üß™ Testing deletion of ${person.name} (ID: ${person.id})...`, 'info');
                    
                    try {
                        // Check if document exists in Firebase
                        const doc = await db.collection('persons').doc(person.id).get();
                        
                        if (doc.exists) {
                            verificationResults.push({
                                person: person,
                                status: 'can_delete',
                                message: 'Document exists in Firebase with matching ID'
                            });
                            log(`‚úÖ ${person.name} can be deleted (document exists)`, 'success');
                        } else {
                            verificationResults.push({
                                person: person,
                                status: 'cannot_delete',
                                message: 'Document not found in Firebase'
                            });
                            log(`‚ùå ${person.name} cannot be deleted (document not found)`, 'error');
                        }
                        
                    } catch (error) {
                        verificationResults.push({
                            person: person,
                            status: 'error',
                            message: 'Error: ' + error.message
                        });
                        log(`‚ùå Error checking ${person.name}: ${error.message}`, 'error');
                    }
                }
                
                // Display verification results
                const canDelete = verificationResults.filter(r => r.status === 'can_delete').length;
                const cannotDelete = verificationResults.filter(r => r.status === 'cannot_delete').length;
                const errors = verificationResults.filter(r => r.status === 'error').length;
                
                let html = `
                    <h3>Verification Results</h3>
                    <div style="margin-bottom: 20px;">
                        <span style="color: #44ff44;">‚úÖ Can Delete: ${canDelete}</span> |
                        <span style="color: #ff4444;">‚ùå Cannot Delete: ${cannotDelete}</span> |
                        <span style="color: #ffaa00;">‚ö†Ô∏è Errors: ${errors}</span>
                    </div>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${verificationResults.map(r => `
                            <div class="person-card ${r.status === 'can_delete' ? '' : 'problematic'}">
                                <strong>${r.person.name}</strong><br>
                                <small>ID: ${r.person.id}</small><br>
                                <span style="color: ${r.status === 'can_delete' ? '#44ff44' : '#ff4444'}">${r.message}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                document.getElementById('verification-results').innerHTML = html;
                
                if (cannotDelete === 0 && errors === 0) {
                    log('‚úÖ VERIFICATION COMPLETE: All persons can be deleted successfully', 'success');
                } else {
                    log(`‚ùå VERIFICATION ISSUES: ${cannotDelete + errors} persons still have problems`, 'error');
                }
                
            } catch (error) {
                log('‚ùå Error during verification: ' + error.message, 'error');
            }
        }

        // Auto-run analysis on page load
        window.addEventListener('load', async () => {
            log('üöÄ Fix Existing Persons tool loaded', 'info');
            
            setTimeout(async () => {
                await analyzePersonIDs();
            }, 1000);
        });
    </script>
</body>
</html>